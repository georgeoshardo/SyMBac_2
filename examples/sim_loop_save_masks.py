import numpy as np
import os
import pickle
from tqdm import tqdm
from joblib import Parallel, delayed
import time
from PIL import Image

# Import the circle function from the provided raster.py file
from raster_geometry import circle

# --- CONFIGURATION ---
# Adjust the output resolution of the PNG masks
RESOLUTION = (5000, 5000)
# Padding around the colony in pixels
PADDING_PX = 100
# The data file generated by sim_loop.py
INPUT_FILE = "simulation_output.pkl"
# Directory to save the final PNG masks
OUTPUT_DIR = "instance_masks_raw"


def get_simulation_bounds(all_frames_data: list) -> tuple[float, float, float, float]:
    """
    Calculates the global bounding box for all cell segments across all frames.

    Args:
        all_frames_data: A list containing the data for every frame.

    Returns:
        A tuple (min_x, max_x, min_y, max_y) representing the bounds.
    """
    all_x = []
    all_y = []

    for _, frame_data in all_frames_data:
        if not frame_data:
            continue
        for seg in frame_data:
            x, y = seg['position']
            r = seg['radius']
            all_x.extend([x - r, x + r])
            all_y.extend([y - r, y + r])

    if not all_x or not all_y:
        return -100, 100, -100, 100

    return min(all_x), max(all_x), min(all_y), max(all_y)


def render_single_frame(
        frame_content: tuple,
        output_dir: str,
        resolution: tuple[int, int],
        transform: dict
):
    """
    Renders a single frame using localized drawing for performance.
    """
    frame_number, frame_data = frame_content
    canvas_height, canvas_width = resolution
    id_canvas = np.zeros((canvas_height, canvas_width), dtype=np.uint16)

    if not frame_data:
        img = Image.fromarray(id_canvas, mode='I;16')
        output_path = os.path.join(output_dir, f"mask_{frame_number:05d}.png")
        img.save(output_path)
        return

    sorted_segments = sorted(frame_data, key=lambda s: s['id'])

    for segment in sorted_segments:
        world_x, world_y = segment['position']
        world_r = segment['radius']
        cell_id = segment['id']

        # --- Coordinate Transformation ---
        pixel_x = (world_x - transform['min_x']) * transform['scale'] + transform['offset_x']
        pixel_y = (world_y - transform['min_y']) * transform['scale'] + transform['offset_y']
        pixel_r = world_r * transform['scale']

        # If radius is tiny, it might not even cover a pixel.
        if pixel_r < 0.5:
            continue

        # --- OPTIMIZATION: Localized Rendering ---
        # 1. Define the local bounding box for the circle.
        x_min = int(np.floor(pixel_x - pixel_r))
        x_max = int(np.ceil(pixel_x + pixel_r))
        y_min = int(np.floor(pixel_y - pixel_r))
        y_max = int(np.ceil(pixel_y + pixel_r))

        # 2. Clip the bounding box to the canvas dimensions.
        clipped_x_min = max(0, x_min)
        clipped_y_min = max(0, y_min)
        clipped_x_max = min(canvas_width, x_max)
        clipped_y_max = min(canvas_height, y_max)

        # If the box is off-canvas, skip to the next segment.
        if clipped_x_max <= clipped_x_min or clipped_y_max <= clipped_y_min:
            continue

        # 3. Define the shape and relative position for the *local* rasterization.
        local_shape = (clipped_y_max - clipped_y_min, clipped_x_max - clipped_x_min)
        local_center_x = pixel_x - clipped_x_min
        local_center_y = pixel_y - clipped_y_min

        # Avoid division by zero if the local shape has a dimension of 0.
        if local_shape[0] == 0 or local_shape[1] == 0:
            continue

        local_relative_pos = (local_center_y / local_shape[0], local_center_x / local_shape[1])

        # 4. Call raster.circle on the small, local canvas.
        local_mask = circle(shape=local_shape, radius=pixel_r, position=local_relative_pos)

        # 5. "Stamp" the local mask onto the main canvas.
        canvas_slice = id_canvas[clipped_y_min:clipped_y_max, clipped_x_min:clipped_x_max]
        canvas_slice[local_mask] = cell_id

    # --- Save the raw ID canvas ---
    output_path = os.path.join(output_dir, f"mask_{frame_number:05d}.png")
    img = Image.fromarray(id_canvas, mode='I;16')
    img.save(output_path)


def main():
    """
    Main function to orchestrate the loading, processing, and rendering of simulation data.
    """
    print(f"Starting raw instance mask rendering process...")

    # --- 1. Setup ---
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    print(f"Clearing output directory: ./{OUTPUT_DIR}/")
    for filename in os.listdir(OUTPUT_DIR):
        if filename.endswith(".png"):
            os.remove(os.path.join(OUTPUT_DIR, filename))

    # --- 2. Load Data ---
    if not os.path.exists(INPUT_FILE):
        print(f"Error: Input file '{INPUT_FILE}' not found.")
        print("Please run sim_loop.py first to generate the simulation data.")
        return

    print(f"Loading data from {INPUT_FILE}...")
    with open(INPUT_FILE, 'rb') as f:
        all_frames = pickle.load(f)

    if not all_frames:
        print("No frames to render.")
        return

    # --- 3. Prepare for Rendering ---
    print("Calculating simulation bounds...")
    min_x, max_x, min_y, max_y = get_simulation_bounds(all_frames)

    # --- 4. Define Coordinate Transformation ---
    world_width = max_x - min_x
    world_height = max_y - min_y
    canvas_height, canvas_width = RESOLUTION

    scale = min(
        (canvas_width - 2 * PADDING_PX) / world_width,
        (canvas_height - 2 * PADDING_PX) / world_height
    )
    offset_x = (canvas_width - world_width * scale) / 2
    offset_y = (canvas_height - world_height * scale) / 2

    transform_params = {
        'min_x': min_x, 'min_y': min_y, 'scale': scale,
        'offset_x': offset_x, 'offset_y': offset_y
    }

    # --- 5. Parallel Rendering ---
    print(f"Rendering {len(all_frames)} frames in parallel...")
    start_time = time.perf_counter()

    Parallel(n_jobs=-1)(
        delayed(render_single_frame)(frame, OUTPUT_DIR, RESOLUTION, transform_params)
        for frame in tqdm(all_frames[::-1], desc="Rendering Frames")
    )

    end_time = time.perf_counter()
    print(f"\nRendering complete.")
    print(f"Total time: {end_time - start_time:.2f} seconds.")
    print(f"Output masks are saved in the '{OUTPUT_DIR}' directory.")


if __name__ == "__main__":
    main()