import numpy as np
import os
import pickle
from tqdm import tqdm
from joblib import Parallel, delayed
import time
from PIL import Image

# --- CONFIGURATION ---
# Adjust the output resolution of the PNGs
RESOLUTION = (5000, 5000)
# Padding around the colony in pixels
PADDING_PX = 100
# The data file generated by sim_loop.py
INPUT_FILE = "simulation_output.pkl"
# Directory to save the final OPL images
OUTPUT_DIR = "opl_images"


def get_simulation_bounds(all_frames_data: list) -> tuple[float, float, float, float]:
    """Calculates the global bounding box for all cell segments across all frames."""
    all_x, all_y = [], []
    for _, frame_data in all_frames_data:
        if not frame_data: continue
        for seg in frame_data:
            x, y = seg['position']
            r = seg['radius']
            all_x.extend([x - r, x + r])
            all_y.extend([y - r, y + r])

    if not all_x or not all_y: return -100, 100, -100, 100
    return min(all_x), max(all_x), min(all_y), max(all_y)


def render_opl_frame(
        frame_number: int,
        segments_by_cell_in_frame: dict,
        output_dir: str,
        resolution: tuple[int, int],
        transform: dict
):
    """
    Renders the OPL for a single frame by modeling cells as a union of spheres.
    """
    canvas_height, canvas_width = resolution
    # Final canvas will sum the OPL of all cells.
    final_opl_canvas = np.zeros((canvas_height, canvas_width), dtype=np.float32)

    if not segments_by_cell_in_frame:
        # If the frame is empty, save a blank image
        img = Image.fromarray(final_opl_canvas.astype(np.uint8), mode='L')
        output_path = os.path.join(output_dir, f"opl_{frame_number:05d}.png")
        img.save(output_path)
        return

    # Process each cell individually
    for cell_id, segments in segments_by_cell_in_frame.items():
        # Create a temporary canvas for the OPL of just this one cell.
        single_cell_opl = np.zeros_like(final_opl_canvas)

        for segment in segments:
            # --- Coordinate Transformation ---
            pixel_x = (segment['position'][0] - transform['min_x']) * transform['scale'] + transform['offset_x']
            pixel_y = (segment['position'][1] - transform['min_y']) * transform['scale'] + transform['offset_y']
            pixel_r = segment['radius'] * transform['scale']

            if pixel_r < 0.5: continue

            # --- Localized OPL Calculation for one sphere ---
            x_min, x_max = int(np.floor(pixel_x - pixel_r)), int(np.ceil(pixel_x + pixel_r))
            y_min, y_max = int(np.floor(pixel_y - pixel_r)), int(np.ceil(pixel_y + pixel_r))

            clipped_x_min, clipped_y_min = max(0, x_min), max(0, y_min)
            clipped_x_max, clipped_y_max = min(canvas_width, x_max), min(canvas_height, y_max)

            if clipped_x_max <= clipped_x_min or clipped_y_max <= clipped_y_min: continue

            # Create a coordinate grid for the local bounding box
            x_range = np.arange(clipped_x_min, clipped_x_max)
            y_range = np.arange(clipped_y_min, clipped_y_max)
            xx, yy = np.meshgrid(x_range, y_range)

            # Calculate the OPL of the sphere within this box
            d_sq = (xx - pixel_x) ** 2 + (yy - pixel_y) ** 2
            # The OPL is proportional to sqrt(R^2 - d^2)
            opl_local = np.sqrt(np.maximum(0, pixel_r ** 2 - d_sq))

            # --- Combine OPLs ---
            # Update the single-cell canvas using the 'maximum' rule to merge sphere volumes
            canvas_slice = single_cell_opl[clipped_y_min:clipped_y_max, clipped_x_min:clipped_x_max]
            single_cell_opl[clipped_y_min:clipped_y_max, clipped_x_min:clipped_x_max] = np.maximum(canvas_slice,
                                                                                                   opl_local)

        # Add this cell's completed OPL to the final frame canvas.
        final_opl_canvas += single_cell_opl

    opl_data_dir = os.path.join(output_dir, "raw_opl_data")
    os.makedirs(opl_data_dir, exist_ok=True)
    opl_data_path = os.path.join(opl_data_dir, f"opl_data_{frame_number:05d}.npy")
    np.save(opl_data_path, final_opl_canvas)

    # --- Save the OPL image ---
    # Normalize the float data to 0-255 to save as an 8-bit grayscale PNG for visualization
    if final_opl_canvas.max() > 0:
        opl_normalized = (final_opl_canvas / final_opl_canvas.max()) * 255
    else:
        opl_normalized = final_opl_canvas

    opl_image_8bit = opl_normalized.astype(np.uint8)

    img = Image.fromarray(opl_image_8bit, mode='L')  # 'L' for 8-bit grayscale
    output_path = os.path.join(output_dir, f"opl_{frame_number:05d}.png")
    img.save(output_path)


def main():
    """Main function to orchestrate the loading, processing, and rendering of OPL data."""
    print(f"Starting Optical Path Length (OPL) rendering process...")

    # --- 1. Setup ---
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    print(f"Clearing output directory: ./{OUTPUT_DIR}/")
    for filename in os.listdir(OUTPUT_DIR):
        if filename.endswith(".png"): os.remove(os.path.join(OUTPUT_DIR, filename))

    # --- 2. Load and Pre-process Data ---
    if not os.path.exists(INPUT_FILE):
        print(f"Error: Input file '{INPUT_FILE}' not found. Please run sim_loop.py first.")
        return

    print(f"Loading data from {INPUT_FILE}...")
    with open(INPUT_FILE, 'rb') as f:
        all_frames_raw = pickle.load(f)

    if not all_frames_raw:
        print("No frames to render.")
        return

    print("Pre-processing data by grouping segments by cell...")
    all_segments_by_cell = {}
    for frame_number, frame_data in all_frames_raw[::-1]:
        segments_in_frame = {}
        if frame_data:
            for seg in frame_data:
                cell_id = seg['id']
                if cell_id not in segments_in_frame:
                    segments_in_frame[cell_id] = []
                segments_in_frame[cell_id].append(seg)
        all_segments_by_cell[frame_number] = segments_in_frame

    # --- 3. Prepare for Rendering ---
    print("Calculating simulation bounds...")
    min_x, max_x, min_y, max_y = get_simulation_bounds(all_frames_raw)

    world_width = max_x - min_x
    world_height = max_y - min_y
    canvas_height, canvas_width = RESOLUTION

    scale = min((canvas_width - 2 * PADDING_PX) / world_width, (canvas_height - 2 * PADDING_PX) / world_height)
    offset_x = (canvas_width - world_width * scale) / 2
    offset_y = (canvas_height - world_height * scale) / 2

    transform_params = {
        'min_x': min_x, 'min_y': min_y, 'scale': scale,
        'offset_x': offset_x, 'offset_y': offset_y
    }

    # --- 4. Parallel Rendering ---
    print(f"Rendering {len(all_segments_by_cell)} frames in parallel...")
    start_time = time.perf_counter()

    Parallel(n_jobs=-1)(
        delayed(render_opl_frame)(frame_num, segments, OUTPUT_DIR, RESOLUTION, transform_params)
        for frame_num, segments in tqdm(all_segments_by_cell.items(), desc="Rendering OPL Frames")
    )

    end_time = time.perf_counter()
    print(f"\nRendering complete.")
    print(f"Total time: {end_time - start_time:.2f} seconds.")
    print(f"Output OPL images are saved in the '{OUTPUT_DIR}' directory.")


if __name__ == "__main__":
    main()